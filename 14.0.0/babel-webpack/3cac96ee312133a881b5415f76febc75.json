{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { SecurityContext, Injectable, EventEmitter, PLATFORM_ID, Component, Inject, Output, Input, NgModule } from '@angular/core';\nimport { throwError } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\nimport { Renderer, marked } from 'marked';\nimport * as i1 from '@angular/common/http';\nimport * as i2 from '@angular/platform-browser';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as Prism from 'prismjs';\nimport { decode } from 'he';\nconst _c0 = [\"*\"];\n\nclass NgxMdService {\n  constructor(_http, _domSanitizer) {\n    this._http = _http;\n    this._domSanitizer = _domSanitizer;\n    this._renderer = new Renderer();\n    this.extendRenderer();\n    this.setMarkedOptions({});\n  } // get the content from remote resource\n\n\n  getContent(path) {\n    return this._http.get(path, {\n      responseType: 'text'\n    }).pipe(map(res => this.extractData(res)), catchError(this.handleError));\n  }\n\n  get renderer() {\n    return this._renderer;\n  } // handle data\n\n\n  extractData(res) {\n    return res || '';\n  }\n\n  setMarkedOptions(options) {\n    options = Object.assign({\n      gfm: true,\n      tables: true,\n      breaks: false,\n      pedantic: false,\n      sanitize: false,\n      smartLists: true,\n      smartypants: false\n    }, options);\n    options.renderer = this._renderer;\n    marked.setOptions(options);\n  } // comple markdown to html\n\n\n  compile(data, sanitize = true) {\n    return this._domSanitizer.sanitize(sanitize ? SecurityContext.HTML : SecurityContext.NONE, marked.parse(data).trim());\n  } // handle error\n\n\n  handleError(error) {\n    const errMsg = error.message ? error.message : error.toString();\n    return throwError(errMsg);\n  } // extend marked render to support todo checkbox\n\n\n  extendRenderer() {\n    this._renderer.listitem = function (text) {\n      if (/^\\s*\\[[x ]\\]\\s*/.test(text)) {\n        text = text.replace(/^\\s*\\[ \\]\\s*/, '<input type=\"checkbox\" class=\"md-checkbox\" disabled> ').replace(/^\\s*\\[x\\]\\s*/, '<input type=\"checkbox\" class=\"md-checkbox\" checked disabled> ');\n        return '<li style=\"list-style: none\">' + text + '</li>';\n      } else {\n        return '<li>' + text + '</li>';\n      }\n    };\n  }\n\n}\n\nNgxMdService.ɵfac = function NgxMdService_Factory(t) {\n  return new (t || NgxMdService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.DomSanitizer));\n};\n\nNgxMdService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxMdService,\n  factory: NgxMdService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxMdService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i1.HttpClient\n    }, {\n      type: i2.DomSanitizer\n    }];\n  }, null);\n})();\n\nclass NgxMdComponent {\n  constructor(_mdService, _el, platformId) {\n    this._mdService = _mdService;\n    this._el = _el;\n    this.platformId = platformId;\n    this.changeLog = [];\n    this.error = new EventEmitter();\n    this.loaded = new EventEmitter();\n    this.rendered = new EventEmitter();\n    /**\n     * Boolean indicating if the markdown content should be sanitized to avoid script injections\n     */\n\n    this.sanitizeHtml = true;\n    this._path = '';\n    this._data = '';\n    this._ext = '';\n  }\n\n  set path(value) {\n    if (value) {\n      this._path = value;\n      this.onPathChange();\n    }\n  }\n\n  set data(value) {\n    if (value) {\n      this._data = value;\n      this.onDataChange(value);\n    }\n  } // on input\n\n\n  onDataChange(data) {\n    if (data) {\n      this._el.nativeElement.innerHTML = this._mdService.compile(data, this.sanitizeHtml);\n    } else {\n      this._el.nativeElement.innerHTML = '';\n    }\n\n    this.highlightContent(false);\n    this.rendered.emit(data);\n  }\n  /**\n   *  After view init\n   */\n\n\n  ngAfterViewInit() {\n    if (this._path) {\n      this.onPathChange();\n    } else if (!this._data) {\n      this.processRaw();\n    }\n  }\n\n  processRaw() {\n    this._md = this.prepare(decode(this._el.nativeElement.innerHTML));\n    this.onDataChange(this._md);\n  }\n  /**\n   * get remote conent;\n   */\n\n\n  onPathChange() {\n    this._ext = this._path && this._path.split('.').splice(-1).join();\n\n    this._mdService.getContent(this._path).pipe(catchError(this.handleError)).subscribe(data => {\n      this._md = this._ext !== 'md' ? '```' + this._ext + '\\n' + data + '\\n```' : data;\n      this.onDataChange(this.prepare(this._md));\n      this.loaded.emit(data);\n    });\n  }\n  /**\n   * catch http error\n   */\n\n\n  handleError(error, caught) {\n    this.error.emit(error);\n    console.error('An error occurred', error); // for demo purposes only\n\n    return error.message || error;\n  }\n  /**\n   * Prepare string\n   */\n\n\n  prepare(raw) {\n    if (!raw) {\n      return '';\n    }\n\n    if (this._ext === 'md' || !this.path) {\n      let isCodeBlock = false;\n      return raw.split('\\n').map(line => {\n        // If the first non-blank chars are an opening/closing code block, toggle the flag\n        if (this.trimLeft(line).substring(0, 3) === '```') {\n          isCodeBlock = !isCodeBlock;\n        }\n\n        return isCodeBlock ? line : line.trim();\n      }).join('\\n');\n    }\n\n    return raw.replace(/\\\"/g, '\\'');\n  }\n  /**\n   * Trim left whitespace\n   */\n\n\n  trimLeft(line) {\n    return line.replace(/^\\s+|\\s+$/g, '');\n  }\n  /**\n   * Use Prism to highlight code snippets only on the browser\n   */\n\n\n  highlightContent(async) {\n    if (isPlatformBrowser(this.platformId)) {\n      Prism.highlightAll(async);\n    }\n  }\n\n}\n\nNgxMdComponent.ɵfac = function NgxMdComponent_Factory(t) {\n  return new (t || NgxMdComponent)(i0.ɵɵdirectiveInject(NgxMdService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PLATFORM_ID));\n};\n\nNgxMdComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: NgxMdComponent,\n  selectors: [[\"markdown\"], [\"\", \"Markdown\", \"\"], [\"ngx-md\"], [\"\", \"NgxMd\", \"\"]],\n  inputs: {\n    path: \"path\",\n    data: \"data\",\n    sanitizeHtml: \"sanitizeHtml\"\n  },\n  outputs: {\n    error: \"error\",\n    loaded: \"loaded\",\n    rendered: \"rendered\"\n  },\n  ngContentSelectors: _c0,\n  decls: 1,\n  vars: 0,\n  template: function NgxMdComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵprojection(0);\n    }\n  },\n  styles: [\".token.operator[_ngcontent-%COMP%], .token.entity[_ngcontent-%COMP%], .token.url[_ngcontent-%COMP%], .language-css[_ngcontent-%COMP%]   .token.string[_ngcontent-%COMP%], .style[_ngcontent-%COMP%]   .token.string[_ngcontent-%COMP%]{background:none}.md-checkbox[_ngcontent-%COMP%]{vertical-align:middle;margin:0 .2em .25em -1.6em;font-size:16px}\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxMdComponent, [{\n    type: Component,\n    args: [{\n      selector: 'markdown,[Markdown],ngx-md,[NgxMd]',\n      template: '<ng-content></ng-content>',\n      styles: [\".token.operator,.token.entity,.token.url,.language-css .token.string,.style .token.string{background:none}.md-checkbox{vertical-align:middle;margin:0 .2em .25em -1.6em;font-size:16px}\\n\"]\n    }]\n  }], function () {\n    return [{\n      type: NgxMdService\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, {\n    error: [{\n      type: Output\n    }],\n    loaded: [{\n      type: Output\n    }],\n    rendered: [{\n      type: Output\n    }],\n    path: [{\n      type: Input\n    }],\n    data: [{\n      type: Input\n    }],\n    sanitizeHtml: [{\n      type: Input\n    }]\n  });\n})();\n\nclass NgxMdConfig {}\n\nNgxMdConfig.ɵfac = function NgxMdConfig_Factory(t) {\n  return new (t || NgxMdConfig)();\n};\n\nNgxMdConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxMdConfig,\n  factory: NgxMdConfig.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxMdConfig, [{\n    type: Injectable\n  }], null, null);\n})(); // import { NgModule } from '@angular/core';\n\n\nclass NgxMdModule {\n  static forRoot() {\n    return {\n      ngModule: NgxMdModule,\n      providers: [NgxMdConfig]\n    };\n  }\n\n}\n\nNgxMdModule.ɵfac = function NgxMdModule_Factory(t) {\n  return new (t || NgxMdModule)();\n};\n\nNgxMdModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxMdModule\n});\nNgxMdModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [NgxMdService],\n  imports: [CommonModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxMdModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [NgxMdComponent],\n      providers: [NgxMdService],\n      exports: [NgxMdComponent]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of ngx-md\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NgxMdComponent, NgxMdModule, NgxMdService };","map":{"version":3,"mappings":"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","names":["NgxMdService","constructor","_domSanitizer","_http","Renderer","extendRenderer","setMarkedOptions","getContent","path","get","responseType","pipe","map","res","extractData","catchError","handleError","renderer","_renderer","options","Object","assign","gfm","tables","breaks","pedantic","sanitize","smartLists","smartypants","marked","setOptions","compile","data","SecurityContext","HTML","NONE","parse","trim","error","errMsg","message","toString","throwError","listitem","text","test","replace","i1","Injectable","args","providedIn","NgxMdComponent","_mdService","_el","platformId","changeLog","EventEmitter","sanitizeHtml","_path","_data","_ext","value","onPathChange","onDataChange","nativeElement","innerHTML","highlightContent","rendered","emit","ngAfterViewInit","processRaw","_md","prepare","decode","split","splice","join","subscribe","loaded","caught","console","raw","isCodeBlock","line","trimLeft","substring","async","isPlatformBrowser","Prism","highlightAll","i0","PLATFORM_ID","Component","selector","template","styles","Inject","Output","Input","NgxMdConfig","NgxMdModule","forRoot","ngModule","providers","CommonModule","NgModule","imports","declarations","exports"],"sources":["/Users/dbuddha/CODEBASE/github/ngx-md/ngx-md/projects/ngx-md/src/lib/ngx-md.service.ts","/Users/dbuddha/CODEBASE/github/ngx-md/ngx-md/projects/ngx-md/src/lib/ngx-md.component.ts","/Users/dbuddha/CODEBASE/github/ngx-md/ngx-md/projects/ngx-md/src/lib/ngx-md.config.ts","/Users/dbuddha/CODEBASE/github/ngx-md/ngx-md/projects/ngx-md/src/lib/ngx-md.module.ts","/Users/dbuddha/CODEBASE/github/ngx-md/ngx-md/projects/ngx-md/src/public-api.ts","/Users/dbuddha/CODEBASE/github/ngx-md/ngx-md/projects/ngx-md/src/ngx-md.ts"],"sourcesContent":["import { Injectable, SecurityContext } from '@angular/core';\nimport { HttpClient, HttpErrorResponse } from '@angular/common/http';\nimport { throwError, Observable } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\nimport { Renderer, marked } from 'marked';\nimport { DomSanitizer } from '@angular/platform-browser';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class NgxMdService {\n  private _renderer: any = new Renderer();\n  constructor(private _http: HttpClient, private _domSanitizer: DomSanitizer) {\n    this.extendRenderer();\n    this.setMarkedOptions({});\n  }\n\n  // get the content from remote resource\n  getContent(path: string): Observable<any> {\n    return this._http.get(path, { responseType: 'text' }).pipe(\n      map(res => this.extractData(res)),\n      catchError(this.handleError)\n    );\n  }\n\n  public get renderer(): Renderer {\n    return this._renderer;\n  }\n\n  // handle data\n  public extractData(res: any): string {\n    return res || '';\n  }\n\n  public setMarkedOptions(options: any) {\n    options = Object.assign(\n      {\n        gfm: true,\n        tables: true,\n        breaks: false,\n        pedantic: false,\n        sanitize: false,\n        smartLists: true,\n        smartypants: false,\n      },\n      options\n    );\n    options.renderer = this._renderer;\n    marked.setOptions(options);\n  }\n\n  // comple markdown to html\n  public compile(data: string, sanitize = true) {\n    return this._domSanitizer.sanitize(\n      sanitize ? SecurityContext.HTML : SecurityContext.NONE,\n      marked.parse(data).trim()\n    );\n  }\n\n  // handle error\n  private handleError(error: HttpErrorResponse): any {\n    const errMsg = error.message ? error.message : error.toString();\n    return throwError(errMsg);\n  }\n\n  // extend marked render to support todo checkbox\n  private extendRenderer() {\n    this._renderer.listitem = function(text: string) {\n      if (/^\\s*\\[[x ]\\]\\s*/.test(text)) {\n        text = text\n          .replace(\n            /^\\s*\\[ \\]\\s*/,\n            '<input type=\"checkbox\" class=\"md-checkbox\" disabled> '\n          )\n          .replace(\n            /^\\s*\\[x\\]\\s*/,\n            '<input type=\"checkbox\" class=\"md-checkbox\" checked disabled> '\n          );\n        return '<li style=\"list-style: none\">' + text + '</li>';\n      } else {\n        return '<li>' + text + '</li>';\n      }\n    };\n  }\n}\n","import {\n  Component,\n  ElementRef,\n  AfterViewInit,\n  Input,\n  PLATFORM_ID,\n  Inject,\n  Output,\n  EventEmitter,\n} from '@angular/core';\nimport { NgxMdService } from './ngx-md.service';\nimport { isPlatformBrowser } from '@angular/common';\nimport * as Prism from 'prismjs';\nimport { Subscribable, Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { decode } from 'he';\n\n@Component({\n  selector: 'markdown,[Markdown],ngx-md,[NgxMd]',\n  template: '<ng-content></ng-content>',\n  styles: [\n    `\n      .token.operator,\n      .token.entity,\n      .token.url,\n      .language-css .token.string,\n      .style .token.string {\n        background: none;\n      }\n      .md-checkbox {\n        vertical-align: middle;\n        margin: 0 0.2em 0.25em -1.6em;\n        font-size: 16px;\n      }\n    `,\n  ],\n})\nexport class NgxMdComponent implements AfterViewInit {\n  _path: string;\n  _data: string;\n  _md: any;\n  _ext: string;\n  changeLog: string[] = [];\n  @Output() error: EventEmitter<any> = new EventEmitter<any>();\n  @Output() loaded: EventEmitter<any> = new EventEmitter<any>();\n  @Output() rendered: EventEmitter<any> = new EventEmitter<any>();\n\n  constructor(\n    public _mdService: NgxMdService,\n    public _el: ElementRef,\n    @Inject(PLATFORM_ID) public platformId: string\n  ) { \n    this._path = '';\n    this._data = '';\n    this._ext = '';\n\n  }\n\n  @Input()\n  set path(value: string) {\n    if (value) {\n      this._path = value;\n      this.onPathChange();\n    }\n  }\n\n  @Input()\n  set data(value: string) {\n    if (value) {\n      this._data = value;\n      this.onDataChange(value);\n    }\n  }\n\n  /**\n   * Boolean indicating if the markdown content should be sanitized to avoid script injections\n   */\n  @Input() public sanitizeHtml = true;\n\n  // on input\n  onDataChange(data: string) {\n    if (data) {\n      this._el.nativeElement.innerHTML = this._mdService.compile(\n        data,\n        this.sanitizeHtml\n      );\n    } else {\n      this._el.nativeElement.innerHTML = '';\n    }\n    this.highlightContent(false);\n    this.rendered.emit(data);\n  }\n\n  /**\n   *  After view init\n   */\n  ngAfterViewInit() {\n    if (this._path) {\n      this.onPathChange();\n    } else if (!this._data) {\n      this.processRaw();\n    }\n  }\n\n  processRaw() {\n    this._md = this.prepare(decode(this._el.nativeElement.innerHTML));\n    this.onDataChange(this._md);\n  }\n\n  /**\n   * get remote conent;\n   */\n  onPathChange() {\n    this._ext =\n      this._path &&\n      this._path\n        .split('.')\n        .splice(-1)\n        .join();\n    this._mdService\n      .getContent(this._path)\n      .pipe(catchError(this.handleError))\n      .subscribe(data => {\n        this._md =\n          this._ext !== 'md' ? '```' + this._ext + '\\n' + data + '\\n```' : data;\n        this.onDataChange(this.prepare(this._md));\n        this.loaded.emit(data);\n      });\n  }\n\n  /**\n   * catch http error\n   */\n  private handleError(error: any, caught: Observable<any>) {\n    this.error.emit(error);\n    console.error('An error occurred', error); // for demo purposes only\n    return error.message || error;\n  }\n\n  /**\n   * Prepare string\n   */\n  prepare(raw: string) {\n    if (!raw) {\n      return '';\n    }\n    if (this._ext === 'md' || !this.path) {\n      let isCodeBlock = false;\n      return raw\n        .split('\\n')\n        .map((line: string) => {\n          // If the first non-blank chars are an opening/closing code block, toggle the flag\n          if (this.trimLeft(line).substring(0, 3) === '```') {\n            isCodeBlock = !isCodeBlock;\n          }\n          return isCodeBlock ? line : line.trim();\n        })\n        .join('\\n');\n    }\n    return raw.replace(/\\\"/g, '\\'');\n  }\n\n  /**\n   * Trim left whitespace\n   */\n  private trimLeft(line: string) {\n    return line.replace(/^\\s+|\\s+$/g, '');\n  }\n\n  /**\n   * Use Prism to highlight code snippets only on the browser\n   */\n  private highlightContent(async: boolean): void {\n    if (isPlatformBrowser(this.platformId)) {\n      Prism.highlightAll(async);\n    }\n  }\n}\n","import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class NgxMdConfig {\n  /** config modue */\n}\n","// import { NgModule } from '@angular/core';\n// import { NgxMdComponent } from './ngx-md.component';\n\n\n\n// @NgModule({\n//   declarations: [\n//     NgxMdComponent\n//   ],\n//   imports: [\n//   ],\n//   exports: [\n//     NgxMdComponent\n//   ]\n// })\n// export class NgxMdModule { }\n\n\n\nimport { CommonModule } from '@angular/common';\nimport { NgModule, ModuleWithProviders } from '@angular/core';\nimport { NgxMdService } from './ngx-md.service';\nimport { NgxMdConfig } from './ngx-md.config';\nimport { NgxMdComponent } from './ngx-md.component';\n\n@NgModule({\n  imports: [CommonModule],\n  declarations: [NgxMdComponent],\n  providers: [NgxMdService],\n  exports: [NgxMdComponent],\n})\nexport class NgxMdModule {\n  public static forRoot(): ModuleWithProviders<NgxMdModule> {\n    return {\n      ngModule: NgxMdModule,\n      providers: [NgxMdConfig],\n    };\n  }\n}\n","/*\n * Public API Surface of ngx-md\n */\n\nexport * from './lib/ngx-md.service';\nexport * from './lib/ngx-md.component';\nexport * from './lib/ngx-md.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"]},"metadata":{},"sourceType":"module"}